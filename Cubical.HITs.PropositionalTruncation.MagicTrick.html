<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Cubical.HITs.PropositionalTruncation.MagicTrick</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">{-

Based on Nicolai Kraus&#39; blog post:
  The Truncation Map |_| : ℕ -&gt; ‖ℕ‖ is nearly Invertible
  https://homotopytypetheory.org/2013/10/28/the-truncation-map-_-ℕ-‖ℕ‖-is-nearly-invertible/

Defines [recover], which definitionally satisfies `recover ∣ x ∣ ≡ x` ([recover∣∣]) for homogeneous types

Also see the follow-up post by Jason Gross:
  Composition is not what you think it is! Why “nearly invertible” isn’t.
  https://homotopytypetheory.org/2014/02/24/composition-is-not-what-you-think-it-is-why-nearly-invertible-isnt/

-}</a>
<a id="532" class="Symbol">{-#</a> <a id="536" class="Keyword">OPTIONS</a> <a id="544" class="Pragma">--cubical</a> <a id="554" class="Pragma">--safe</a> <a id="561" class="Symbol">#-}</a>

<a id="566" class="Keyword">module</a> <a id="573" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html" class="Module">Cubical.HITs.PropositionalTruncation.MagicTrick</a> <a id="621" class="Keyword">where</a>

<a id="628" class="Keyword">open</a> <a id="633" class="Keyword">import</a> <a id="640" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a>
<a id="668" class="Keyword">open</a> <a id="673" class="Keyword">import</a> <a id="680" href="Cubical.Foundations.Function.html" class="Module">Cubical.Foundations.Function</a>
<a id="709" class="Keyword">open</a> <a id="714" class="Keyword">import</a> <a id="721" href="Cubical.Foundations.Path.html" class="Module">Cubical.Foundations.Path</a>
<a id="746" class="Keyword">open</a> <a id="751" class="Keyword">import</a> <a id="758" href="Cubical.Foundations.Pointed.html" class="Module">Cubical.Foundations.Pointed</a>
<a id="786" class="Keyword">open</a> <a id="791" class="Keyword">import</a> <a id="798" href="Cubical.Foundations.Pointed.Homogeneous.html" class="Module">Cubical.Foundations.Pointed.Homogeneous</a>

<a id="839" class="Keyword">open</a> <a id="844" class="Keyword">import</a> <a id="851" href="Cubical.HITs.PropositionalTruncation.Base.html" class="Module">Cubical.HITs.PropositionalTruncation.Base</a>
<a id="893" class="Keyword">open</a> <a id="898" class="Keyword">import</a> <a id="905" href="Cubical.HITs.PropositionalTruncation.Properties.html" class="Module">Cubical.HITs.PropositionalTruncation.Properties</a>

<a id="954" class="Keyword">module</a> <a id="Recover"></a><a id="961" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#961" class="Module">Recover</a> <a id="969" class="Symbol">{</a><a id="970" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#970" class="Bound">ℓ</a><a id="971" class="Symbol">}</a> <a id="973" class="Symbol">(</a><a id="974" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#974" class="Bound">A∙</a> <a id="977" class="Symbol">:</a> <a id="979" href="Cubical.Foundations.Pointed.Base.html#309" class="Function">Pointed</a> <a id="987" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#970" class="Bound">ℓ</a><a id="988" class="Symbol">)</a> <a id="990" class="Symbol">(</a><a id="991" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#991" class="Bound">h</a> <a id="993" class="Symbol">:</a> <a id="995" href="Cubical.Foundations.Pointed.Homogeneous.html#820" class="Function">isHomogeneous</a> <a id="1009" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#974" class="Bound">A∙</a><a id="1011" class="Symbol">)</a> <a id="1013" class="Keyword">where</a>
  <a id="1021" class="Keyword">private</a>
    <a id="Recover.A"></a><a id="1033" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1033" class="Function">A</a> <a id="1035" class="Symbol">=</a> <a id="1037" href="Cubical.Foundations.Structure.html#484" class="Function">typ</a> <a id="1041" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#974" class="Bound">A∙</a>
    <a id="Recover.a"></a><a id="1048" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1048" class="Function">a</a> <a id="1050" class="Symbol">=</a> <a id="1052" href="Cubical.Foundations.Pointed.Base.html#385" class="Function">pt</a> <a id="1055" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#974" class="Bound">A∙</a>

  <a id="Recover.toEquivPtd"></a><a id="1061" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1061" class="Function">toEquivPtd</a> <a id="1072" class="Symbol">:</a> <a id="1074" href="Cubical.HITs.PropositionalTruncation.Base.html#259" class="Datatype Operator">∥</a> <a id="1076" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1033" class="Function">A</a> <a id="1078" href="Cubical.HITs.PropositionalTruncation.Base.html#259" class="Datatype Operator">∥</a> <a id="1080" class="Symbol">→</a> <a id="1082" href="Cubical.Core.Primitives.html#6426" class="Function">Σ[</a> <a id="1085" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1085" class="Bound">B∙</a> <a id="1088" href="Cubical.Core.Primitives.html#6426" class="Function">∈</a> <a id="1090" href="Cubical.Foundations.Pointed.Base.html#309" class="Function">Pointed</a> <a id="1098" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#970" class="Bound">ℓ</a> <a id="1100" href="Cubical.Core.Primitives.html#6426" class="Function">]</a> <a id="1102" class="Symbol">(</a><a id="1103" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1033" class="Function">A</a> <a id="1105" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1107" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1048" class="Function">a</a><a id="1108" class="Symbol">)</a> <a id="1110" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1112" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1085" class="Bound">B∙</a>
  <a id="1117" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1061" class="Function">toEquivPtd</a> <a id="1128" class="Symbol">=</a> <a id="1130" href="Cubical.HITs.PropositionalTruncation.Properties.html#591" class="Function">rec</a> <a id="1134" class="Symbol">(</a><a id="1135" href="Cubical.Foundations.Prelude.html#10812" class="Function">isContr→isProp</a> <a id="1150" class="Symbol">(_</a> <a id="1153" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1155" class="Symbol">λ</a> <a id="1157" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1157" class="Bound">p</a> <a id="1159" class="Symbol">→</a> <a id="1161" href="Cubical.Foundations.Prelude.html#7317" class="Function">contrSingl</a> <a id="1172" class="Symbol">(</a><a id="1173" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="1177" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1157" class="Bound">p</a><a id="1178" class="Symbol">)))</a> <a id="1182" class="Symbol">(λ</a> <a id="1185" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1185" class="Bound">x</a> <a id="1187" class="Symbol">→</a> <a id="1189" class="Symbol">(</a><a id="1190" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1033" class="Function">A</a> <a id="1192" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1194" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1185" class="Bound">x</a><a id="1195" class="Symbol">)</a> <a id="1197" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1199" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#991" class="Bound">h</a> <a id="1201" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1185" class="Bound">x</a><a id="1202" class="Symbol">)</a>
  <a id="1206" class="Keyword">private</a>
    <a id="Recover.B∙"></a><a id="1218" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1218" class="Function">B∙</a> <a id="1221" class="Symbol">:</a> <a id="1223" href="Cubical.HITs.PropositionalTruncation.Base.html#259" class="Datatype Operator">∥</a> <a id="1225" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1033" class="Function">A</a> <a id="1227" href="Cubical.HITs.PropositionalTruncation.Base.html#259" class="Datatype Operator">∥</a> <a id="1229" class="Symbol">→</a> <a id="1231" href="Cubical.Foundations.Pointed.Base.html#309" class="Function">Pointed</a> <a id="1239" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#970" class="Bound">ℓ</a>
    <a id="1245" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1218" class="Function">B∙</a> <a id="1248" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1248" class="Bound">tx</a> <a id="1251" class="Symbol">=</a> <a id="1253" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="1257" class="Symbol">(</a><a id="1258" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1061" class="Function">toEquivPtd</a> <a id="1269" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1248" class="Bound">tx</a><a id="1271" class="Symbol">)</a>

  <a id="1276" class="Comment">-- the key observation is that B∙ ∣ x ∣ is definitionally equal to (A , x)</a>
  <a id="1353" class="Keyword">private</a>
    <a id="Recover.obvs"></a><a id="1365" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1365" class="Function">obvs</a> <a id="1370" class="Symbol">:</a> <a id="1372" class="Symbol">∀</a> <a id="1374" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1374" class="Bound">x</a> <a id="1376" class="Symbol">→</a> <a id="1378" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1218" class="Function">B∙</a> <a id="1381" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a> <a id="1383" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1374" class="Bound">x</a> <a id="1385" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a> <a id="1387" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1389" class="Symbol">(</a><a id="1390" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1033" class="Function">A</a> <a id="1392" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1394" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1374" class="Bound">x</a><a id="1395" class="Symbol">)</a>
    <a id="1401" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1365" class="Function">obvs</a> <a id="1406" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1406" class="Bound">x</a> <a id="1408" class="Symbol">=</a> <a id="1410" href="Cubical.Foundations.Prelude.html#858" class="Function">refl</a> <a id="1415" class="Comment">-- try it: `C-c C-n B∙ ∣ x ∣` gives `(A , x)`</a>

  <a id="1464" class="Comment">-- thus any truncated element (of a homogeneous type) can be recovered by agda&#39;s normalizer!</a>

  <a id="Recover.recover"></a><a id="1560" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1560" class="Function">recover</a> <a id="1568" class="Symbol">:</a> <a id="1570" class="Symbol">∀</a> <a id="1572" class="Symbol">(</a><a id="1573" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1573" class="Bound">tx</a> <a id="1576" class="Symbol">:</a> <a id="1578" href="Cubical.HITs.PropositionalTruncation.Base.html#259" class="Datatype Operator">∥</a> <a id="1580" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1033" class="Function">A</a> <a id="1582" href="Cubical.HITs.PropositionalTruncation.Base.html#259" class="Datatype Operator">∥</a><a id="1583" class="Symbol">)</a> <a id="1585" class="Symbol">→</a> <a id="1587" href="Cubical.Foundations.Structure.html#484" class="Function">typ</a> <a id="1591" class="Symbol">(</a><a id="1592" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1218" class="Function">B∙</a> <a id="1595" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1573" class="Bound">tx</a><a id="1597" class="Symbol">)</a>
  <a id="1601" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1560" class="Function">recover</a> <a id="1609" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1609" class="Bound">tx</a> <a id="1612" class="Symbol">=</a> <a id="1614" href="Cubical.Foundations.Pointed.Base.html#385" class="Function">pt</a> <a id="1617" class="Symbol">(</a><a id="1618" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1218" class="Function">B∙</a> <a id="1621" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1609" class="Bound">tx</a><a id="1623" class="Symbol">)</a>

  <a id="Recover.recover∣∣"></a><a id="1628" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1628" class="Function">recover∣∣</a> <a id="1638" class="Symbol">:</a> <a id="1640" class="Symbol">∀</a> <a id="1642" class="Symbol">(</a><a id="1643" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1643" class="Bound">x</a> <a id="1645" class="Symbol">:</a> <a id="1647" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1033" class="Function">A</a><a id="1648" class="Symbol">)</a> <a id="1650" class="Symbol">→</a> <a id="1652" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1560" class="Function">recover</a> <a id="1660" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a> <a id="1662" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1643" class="Bound">x</a> <a id="1664" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a> <a id="1666" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1668" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1643" class="Bound">x</a>
  <a id="1672" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1628" class="Function">recover∣∣</a> <a id="1682" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1682" class="Bound">x</a> <a id="1684" class="Symbol">=</a> <a id="1686" href="Cubical.Foundations.Prelude.html#858" class="Function">refl</a> <a id="1691" class="Comment">-- try it: `C-c C-n recover ∣ x ∣` gives `x`</a>

  <a id="1739" class="Keyword">private</a>
    <a id="1751" class="Comment">-- notice that the following typechecks because typ (B∙ ∣ x ∣) is definitionally equal to to A, but</a>
    <a id="1855" class="Comment">--  `recover : ∥ A ∥ → A` does not because typ (B∙ tx) is not definitionally equal to A (though it is</a>
    <a id="1961" class="Comment">--  judegmentally equal to A by cong typ (snd (toEquivPtd tx)) : A ≡ typ (B∙ tx))</a>
    <a id="Recover.obvs2"></a><a id="2047" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2047" class="Function">obvs2</a> <a id="2053" class="Symbol">:</a> <a id="2055" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1033" class="Function">A</a> <a id="2057" class="Symbol">→</a> <a id="2059" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1033" class="Function">A</a>
    <a id="2065" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2047" class="Function">obvs2</a> <a id="2071" class="Symbol">=</a> <a id="2073" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1560" class="Function">recover</a> <a id="2081" href="Cubical.Foundations.Function.html#243" class="Function Operator">∘</a> <a id="2083" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣_∣</a>

    <a id="2092" class="Comment">-- one might wonder if (cong recover (squash ∣ x ∣ ∣ y ∣)) therefore has type x ≡ y, but thankfully</a>
    <a id="2196" class="Comment">--  typ (B∙ (squash ∣ x ∣ ∣ y ∣ i)) is *not* A (it&#39;s a messy hcomp involving h x and h y)</a>
    <a id="Recover.recover-squash"></a><a id="2290" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2290" class="Function">recover-squash</a> <a id="2305" class="Symbol">:</a> <a id="2307" class="Symbol">∀</a> <a id="2309" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2309" class="Bound">x</a> <a id="2311" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2311" class="Bound">y</a> <a id="2313" class="Symbol">→</a> <a id="2315" class="Comment">-- x ≡ y -- this raises an error</a>
                             <a id="2377" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="2383" class="Symbol">(λ</a> <a id="2386" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2386" class="Bound">i</a> <a id="2388" class="Symbol">→</a> <a id="2390" href="Cubical.Foundations.Structure.html#484" class="Function">typ</a> <a id="2394" class="Symbol">(</a><a id="2395" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1218" class="Function">B∙</a> <a id="2398" class="Symbol">(</a><a id="2399" href="Cubical.HITs.PropositionalTruncation.Base.html#315" class="InductiveConstructor">squash</a> <a id="2406" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a> <a id="2408" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2309" class="Bound">x</a> <a id="2410" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a> <a id="2412" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a> <a id="2414" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2311" class="Bound">y</a> <a id="2416" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a> <a id="2418" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2386" class="Bound">i</a><a id="2419" class="Symbol">)))</a> <a id="2423" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2309" class="Bound">x</a> <a id="2425" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2311" class="Bound">y</a>
    <a id="2431" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2290" class="Function">recover-squash</a> <a id="2446" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2446" class="Bound">x</a> <a id="2448" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2448" class="Bound">y</a> <a id="2450" class="Symbol">=</a> <a id="2452" href="Cubical.Foundations.Prelude.html#1059" class="Function">cong</a> <a id="2457" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1560" class="Function">recover</a> <a id="2465" class="Symbol">(</a><a id="2466" href="Cubical.HITs.PropositionalTruncation.Base.html#315" class="InductiveConstructor">squash</a> <a id="2473" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a> <a id="2475" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2446" class="Bound">x</a> <a id="2477" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a> <a id="2479" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a> <a id="2481" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2448" class="Bound">y</a> <a id="2483" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a><a id="2484" class="Symbol">)</a>


<a id="2488" class="Comment">-- Demo, adapted from:</a>
<a id="2511" class="Comment">-- https://bitbucket.org/nicolaikraus/agda/src/e30d70c72c6af8e62b72eefabcc57623dd921f04/trunc-inverse.lagda</a>

<a id="2620" class="Keyword">private</a>
  <a id="2630" class="Keyword">open</a> <a id="2635" class="Keyword">import</a> <a id="2642" href="Cubical.Data.Nat.html" class="Module">Cubical.Data.Nat</a>
  <a id="2661" class="Keyword">open</a> <a id="2666" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#961" class="Module">Recover</a> <a id="2674" class="Symbol">(</a><a id="2675" href="Cubical.Data.Nat.Base.html#209" class="Datatype">ℕ</a> <a id="2677" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2679" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="2683" class="Symbol">)</a> <a id="2685" class="Symbol">(</a><a id="2686" href="Cubical.Foundations.Pointed.Homogeneous.html#3149" class="Function">isHomogeneousDiscrete</a> <a id="2708" href="Cubical.Data.Nat.Properties.html#568" class="Function">discreteℕ</a><a id="2717" class="Symbol">)</a>

  <a id="2722" class="Comment">-- only `∣hidden∣` is exported, `hidden` is no longer in scope</a>
  <a id="2787" class="Keyword">module</a> <a id="2794" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2794" class="Module">_</a> <a id="2796" class="Keyword">where</a>
    <a id="2806" class="Keyword">private</a>
      <a id="2820" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2820" class="Function">hidden</a> <a id="2827" class="Symbol">:</a> <a id="2829" href="Cubical.Data.Nat.Base.html#209" class="Datatype">ℕ</a>
      <a id="2837" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2820" class="Function">hidden</a> <a id="2844" class="Symbol">=</a> <a id="2846" class="Number">17</a>

    <a id="2854" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2854" class="Function">∣hidden∣</a> <a id="2863" class="Symbol">:</a> <a id="2865" href="Cubical.HITs.PropositionalTruncation.Base.html#259" class="Datatype Operator">∥</a> <a id="2867" href="Cubical.Data.Nat.Base.html#209" class="Datatype">ℕ</a> <a id="2869" href="Cubical.HITs.PropositionalTruncation.Base.html#259" class="Datatype Operator">∥</a>
    <a id="2875" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2854" class="Function">∣hidden∣</a> <a id="2884" class="Symbol">=</a> <a id="2886" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a> <a id="2888" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2820" class="Function">hidden</a> <a id="2895" href="Cubical.HITs.PropositionalTruncation.Base.html#297" class="InductiveConstructor Operator">∣</a>

  <a id="2900" class="Comment">-- we can still recover the value, even though agda can no longer see `hidden`!</a>
  <a id="test"></a><a id="2982" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2982" class="Function">test</a> <a id="2987" class="Symbol">:</a> <a id="2989" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#1560" class="Function">recover</a> <a id="2997" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2854" class="Function">∣hidden∣</a> <a id="3006" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3008" class="Number">17</a>
  <a id="3013" href="Cubical.HITs.PropositionalTruncation.MagicTrick.html#2982" class="Function">test</a> <a id="3018" class="Symbol">=</a> <a id="3020" href="Cubical.Foundations.Prelude.html#858" class="Function">refl</a> <a id="3025" class="Comment">-- try it: `C-c C-n recover ∣hidden∣` gives `17`</a>
              <a id="3088" class="Comment">--         `C-c C-n hidden` gives an error</a>

  <a id="3134" class="Comment">-- Finally, note that the definition of recover is independent of the proof that A is homogeneous. Thus we</a>
  <a id="3243" class="Comment">--  still can definitionally recover information hidden by ∣_∣ as long as we permit holes. Try replacing</a>
  <a id="3350" class="Comment">--  `isHomogeneousDiscrete discreteℕ` above with a hole (`?`) and notice that everything still works</a>
</pre></body></html>